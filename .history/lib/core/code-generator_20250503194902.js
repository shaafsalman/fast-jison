/**
 * lib/core/code-generator.js
 * 
 * Generates JavaScript code for parsers
 * 
 * Refactorings applied:
 * - Extract Class: Separated code generation from generator classes
 * - Decompose Conditional: Simplified generation logic
 * - Replace Method with Method Object: Better organization of generation steps
 */

"use strict";

const JSONSelect = require('JSONSelect');
const esprima = require('esprima');
const escodegen = require('escodegen');

/**
 * Generates JavaScript code for parsers
 */
class CodeGenerator {
    // Variable id counter and token characters for unique variable names
    static nextVariableId = 0;
    static variableTokens = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
    static variableTokensLength = 64; // Length of variableTokens string
    
    /**
     * Helper function to create objects with repeated values
     * e.g., o([1, 3, 4], [6, 7], { 5: 8 }) = { 1: [6, 7]; 3: [6, 7], 4: [6, 7], 5: 8 }
     */
    static createObjectCode = 'o=function(k,v,o,l){' +
        'for(o=o||{},l=k.length;l--;o[k[l]]=v);' +
        'return o}';

    /**
     * Generate parser code based on the specified options
     * @param {Object} generator - Parser generator instance
     * @param {Object} options - Generation options
     * @returns {String} - Generated parser code
     */
    static generate(generator, options = {}) {
        // Combine generator options with passed options
        options = Object.assign({}, generator.options, options);
        
        // Validate module name
        if (!options.moduleName || !options.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {
            options.moduleName = "parser";
        }
        
        // Generate appropriate module type
        switch (options.moduleType) {
            case "js":
                return this.generateModule(generator, options);
            case "amd":
                return this.generateAMDModule(generator, options);
            default:
                return this.generateCommonJSModule(generator, options);
        }
    }
    
    /**
     * Generate a standard JavaScript module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated module code
     */
    static generateModule(generator, options) {
        const moduleName = options.moduleName || "parser";
        let out = "/* parser generated by jison " + generator.version + " */\n";
        
        // Add module documentation
        out += this.generateDocumentation();
        
        // Add module declaration
        out += (moduleName.match(/\./) ? moduleName : "var " + moduleName) +
                " = " + this.generateModuleExpr(generator);
        
        return out;
    }
    
    /**
     * Generate an AMD module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated AMD module code
     */
    static generateAMDModule(generator, options) {
        const module = this.generateModule_(generator);
        
        let out = '\n\ndefine(function(require){\n' +
            module.commonCode +
            '\nvar parser = ' + module.moduleCode +
            "\n" + generator.moduleInclude;
            
        // Add lexer if available
        if (generator.lexer && generator.lexer.generateModule) {
            out += '\n' + generator.lexer.generateModule() +
                  '\nparser.lexer = lexer;';
        }
        
        out += '\nreturn parser;' + '\n});';
        
        return out;
    }
    
    /**
     * Generate a CommonJS module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated CommonJS module code
     */
    static generateCommonJSModule(generator, options) {
        const moduleName = options.moduleName || "parser";
        
        let out = this.generateModule(generator, options) +
            "\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {" +
            "\nexports.parser = " + moduleName + ";" +
            "\nexports.Parser = " + moduleName + ".Parser;" +
            "\nexports.parse = function () { return " + moduleName + ".parse.apply(" + moduleName + ", arguments); };" +
            "\nexports.main = " + String(options.moduleMain || this.commonjsMain) + ";" +
            "\nif (typeof module !== 'undefined' && require.main === module) {\n" +
            "  exports.main(process.argv.slice(1));\n}" +
            "\n}";
            
        return out;
    }
    
    /**
     * Generate a module expression (used by other generators)
     * @param {Object} generator - Parser generator
     * @returns {String} - Generated module expression
     */
    static generateModuleExpr(generator) {
        const module = this.generateModule_(generator);
        
        let out = "(function(){\n";
        out += module.commonCode;
        out += "\nvar parser = " + module.moduleCode;
        out += "\n" + generator.moduleInclude;
        
        // Add lexer if available
        if (generator.lexer && generator.lexer.generateModule) {
            out += generator.lexer.generateModule();
            out += "\nparser.lexer = lexer;";
        }
        
        out += "\nfunction Parser () {\n  this.yy = {};\n}\n" +
            "Parser.prototype = parser;" +
            "parser.Parser = Parser;" +
            "\nreturn new Parser;\n})();";
            
        return out;
    }
    
    /**
     * Generate module documentation
     * @returns {String} - Documentation
     */
    static generateDocumentation() {
        return "/*\n" +
            "  Returns a Parser object of the following structure:\n" +
            "\n" +
            "  Parser: {\n" +
            "    yy: {}\n" +
            "  }\n" +
            "\n" +
            "  Parser.prototype: {\n" +
            "    yy: {},\n" +
            "    trace: function(),\n" +
            "    symbols_: {associative list: name ==> number},\n" +
            "    terminals_: {associative list: number ==> name},\n" +
            "    productions_: [...],\n" +
            "    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n" +
            "    table: [...],\n" +
            "    defaultActions: {...},\n" +
            "    parseError: function(str, hash),\n" +
            "    parse: function(input),\n" +
            "\n" +
            "    lexer: {\n" +
            "        EOF: 1,\n" +
            "        parseError: function(str, hash),\n" +
            "        setInput: function(input),\n" +
            "        input: function(),\n" +
            "        unput: function(str),\n" +
            "        more: function(),\n" +
            "        less: function(n),\n" +
            "        pastInput: function(),\n" +
            "        upcomingInput: function(),\n" +
            "        showPosition: function(),\n" +
            "        test_match: function(regex_match_array, rule_index),\n" +
            "        next: function(),\n" +
            "        lex: function(),\n" +
            "        begin: function(condition),\n" +
            "        popState: function(),\n" +
            "        _currentRules: function(),\n" +
            "        topState: function(),\n" +
            "        pushState: function(condition),\n" +
            "\n" +
            "        options: {\n" +
            "            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n" +
            "            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n" +
            "            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n" +
            "        },\n" +
            "\n" +
            "        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n" +
            "        rules: [...],\n" +
            "        conditions: {associative list: name ==> set},\n" +
            "    }\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  token location info (@$, _$, etc.): {\n" +
            "    first_line: n,\n" +
            "    last_line: n,\n" +
            "    first_column: n,\n" +
            "    last_column: n,\n" +
            "    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n" +
            "    text:        (matched text)\n" +
            "    token:       (the produced terminal token, if any)\n" +
            "    line:        (yylineno)\n" +
            "  }\n" +
            "  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n" +
            "    loc:         (yylloc)\n" +
            "    expected:    (string describing the set of expected tokens)\n" +
            "    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n" +
            "  }\n" +
            "*/\n";
    }
    
    /**
     * Core method to generate the parser module code parts
     * @param {Object} generator - Parser generator
     * @returns {Object} - Module code parts (common code and module code)
     * @private
     */
    static generateModule_(generator) {
        // Process the parse function
        let parseFn = String(this.parse);
        
        // Remove error recovery code if not needed
        if (!generator.hasErrorRecovery) {
            parseFn = this.removeErrorRecovery(parseFn);
        }
        
        // Add token stack functionality if requested
        if (generator.options['token-stack']) {
            parseFn = this.addTokenStack(parseFn);
        }
        
        // Generate table code
        const tableCode = this.generateTableCode(generator.table);
        
        // Generate module code with all parser components
        const moduleCode = "{" + [
            "trace: " + String(generator.trace || this.trace),
            "yy: {}",
            "symbols_: " + JSON.stringify(generator.symbols_),
            "terminals_: " + JSON.stringify(generator.terminals_).replace(/"([0-9]+)":/g, "$1:"),
            "productions_: " + JSON.stringify(generator.productions_),
            "performAction: " + String(generator.performAction),
            "table: " + tableCode.moduleCode,
            "defaultActions: " + JSON.stringify(generator.defaultActions).replace(/"([0-9]+)":/g, "$1:"),
            "parseError: " + String(generator.parseError || (generator.hasErrorRecovery ? this.traceParseError : this.parseError)),
            "parse: " + parseFn
        ].join(",\n") + "};";
        
        return {
            commonCode: tableCode.commonCode,
            moduleCode: moduleCode
        };
    }
    
    /**
     * Generate optimized code for the parser table
     * @param {Object} table - Parser table
     * @returns {Object} - Table code parts (common code and module code)
     * @private
     */
    static generateTableCode(table) {
        // Start with JSON representation of table
        let moduleCode = JSON.stringify(table);
        const variables = [this.createObjectCode];
        
        // Remove quotes around numeric property names for better readability
        moduleCode = moduleCode.replace(/"([0-9]+)"(?=:)/g, "$1");
        
        // Replace objects with repeated values using function calls for optimization
        moduleCode = moduleCode.replace(/\{\d+:[^\}]+,\d+:[^\}]+\}/g, object => {
            // Find values that occur multiple times in the object
            const keys = {};
            const keyValues = [];
            let maxKeyCount = 0;
            let frequentValue;
            
            // Parse key-value pairs from the object
            const keyValueMatcher = /(\d+):([^:]+)(?=,\d+:|\})/g;
            let keyValue;
            
            while ((keyValue = keyValueMatcher.exec(object))) {
                const key = keyValue[1];
                const value = keyValue[2];
                
                // Track keys for each value
                if (!keys[value]) {
                    keys[value] = [key];
                } else {
                    keys[value].push(key);
                }
                
                // Keep track of most frequent value
                if (keys[value].length > maxKeyCount) {
                    maxKeyCount = keys[value].length;
                    frequentValue = value;
                }
            }
            
            // Only optimize if a value occurs multiple times
            if (maxKeyCount > 1) {
                // Collect non-frequent values for the remainder object
                for (const value in keys) {
                    if (value !== frequentValue) {
                        keys[value].forEach(key => {
                            keyValues.push(key + ':' + value);
                        });
                    }
                }
                
                // Create optimized function call
                const remainderObj = keyValues.length ? ',{' + keyValues.join(',') + '}' : '';
                return 'o([' + keys[frequentValue].join(',') + '],' + frequentValue + remainderObj + ')';
            }
            
            return object;
        });
        
        // Optimize repeated number lists using variables
        const lists = {};
        const listMatcher = /\[[0-9,]+\]/g;
        let list;
        
        // First pass: count occurrences
        while ((list = listMatcher.exec(moduleCode))) {
            lists[list] = (lists[list] || 0) + 1;
        }
        
        // Second pass: replace frequently occurring lists with variables
        moduleCode = moduleCode.replace(listMatcher, list => {
            let listId = lists[list];
            
            // Only create variables for lists that occur multiple times
            if (typeof listId === 'number') {
                if (listId === 1) {
                    lists[list] = list; // Use list directly if it only occurs once
                } else {
                    // Create a variable for frequently occurring lists
                    const varName = this.createVariable();
                    variables.push(varName + '=' + list);
                    lists[list] = varName;
                }
                listId = lists[list];
            }
            
            return listId;
        });
        
        return {
            commonCode: 'var ' + variables.join(',') + ';',
            moduleCode: moduleCode
        };
    }
    
    /**
     * Add token stack functionality to the parse function
     * @param {String} fn - Parse function code
     * @returns {String} - Modified parse function code
     * @private
     */
    static addTokenStack(fn) {
        try {
            // Parse the function to get an AST
            const ast = esprima.parse(fn);
            
            // Create AST for the token stack lex function
            const stackAst = esprima.parse(String(this.tokenStackLex)).body[0];
            stackAst.id.name = 'lex';
            
            // Find the _token_stack label in the parse function
            const labeled = JSONSelect.match(':has(:root > .label > .name:val("_token_stack"))', ast);
            
            // Replace the label body with the token stack function
            labeled[0].body = stackAst;
            
            // Generate code from the modified AST
            return escodegen.generate(ast)
                .replace(/_token_stack:\s?/, "")
                .replace(/\\\\n/g, "\\n");
        } catch (e) {
            // If AST manipulation fails, return the original function
            return fn;
        }
    }
    
    /**
     * Remove error recovery code from the parse function
     * @param {String} fn - Parse function code
     * @returns {String} - Modified parse function code
     * @private
     */
    static removeErrorRecovery(fn) {
        try {
            // Parse the function to get an AST
            const ast = esprima.parse(fn);
            
            // Find the _handle_error label in the parse function
            const labeled = JSONSelect.match(':has(:root > .label > .name:val("_handle_error"))', ast);
            
            // Modify the AST to remove error recovery code
            const reduced_code = labeled[0].body.consequent.body[3].consequent.body;
            
            // Remove error_rule_depth-related code
            reduced_code[0] = labeled[0].body.consequent.body[1];
            
            // Remove recoverable property
            reduced_code[4].expression.arguments[1].properties.pop();
            
            // Set modified code back to labeled block
            labeled[0].body.consequent.body = reduced_code;
            
            // Generate code from the modified AST
            return escodegen.generate(ast)
                .replace(/_handle_error:\s?/, "")
                .replace(/\\\\n/g, "\\n");
        } catch (e) {
            // If AST manipulation fails, return the original function
            return fn;
        }
    }
    
    /**
     * Token stack lex function implementation
     * Used in addTokenStack
     * @private
     */
    static tokenStackLex() {
        var token;
        token = tstack.pop() || lexer.lex() || EOF;
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            if (token instanceof Array) {
                tstack = token;
                token = tstack.pop();
            }
            token = self.symbols_[token] || token;
        }
        return token;
    }
    
    /**
     * Create a variable with a unique name
     * @returns {String} - Variable name
     * @private
     */
    static createVariable() {
        let id = this.nextVariableId++;
        let name = '$V';
        
        do {
            name += this.variableTokens[id % this.variableTokensLength];
            id = Math.floor(id / this.variableTokensLength);
        } while (id !== 0);
        
        return name;
    }
    
    /**
     * Default trace parse error function
     * @param {String} err - Error message
     * @param {Object} hash - Error details
     * @private
     */
    static traceParseError(err, hash) {
        this.trace(err);
    }
    
    /**
     * Default parse error function
     * @param {String} str - Error message
     * @param {Object} hash - Error details
     * @private
     */
    static parseError(str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            const error = new Error(str);
            error.hash = hash;
            throw error;
        }
    }
    
    /**
     * Default trace function
     * @private
     */
    static trace() {
        // No-op by default
    }
    
    /**
     * Default main method for generated CommonJS modules
     * @param {Array} args - Command line arguments
     * @returns {*} - Parse result
     * @private
     */
    static commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: ' + args[0] + ' FILE');
            process.exit(1);
        }
        const source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    }
    
    /**
     * Parse implementation that's used as a template in generated parsers
     * @param {String} input - Input to parse
     * @returns {*} - Parse result
     * @private
     */
    static parse(input) {
        const self = this;
        const stack = [0];
        const tstack = []; // token stack
        const vstack = [null]; // semantic value stack
        const lstack = []; // location stack
        const table = this.table;
        let yytext = '';
        let yylineno = 0;
        let yyleng = 0;
        let recovering = 0;
        const TERROR = 2;
        const EOF = 1;

        const args = lstack.slice.call(arguments, 1);

        const lexer = Object.create(this.lexer);
        const sharedState = { yy: {} };
        
        // Copy state
        for (const k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                sharedState.yy[k] = this.yy[k];
            }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        
        if (typeof lexer.yylloc == 'undefined') {
            lexer.yylloc = {};
        }
        
        const yyloc = lexer.yylloc;
        lstack.push(yyloc);

        const ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
            this.parseError = sharedState.yy.parseError;
        } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
        }

    _token_stack:
        var lex = function() {
            let token;
            token = lexer.lex() || EOF;
            
            // If token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };

        let symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
        
        while (true) {
            // Retrieve state number from top of stack
            state = stack[stack.length - 1];

            // Use default actions if available
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                if (symbol === null || typeof symbol == 'undefined') {
                    symbol = lex();
                }
                // Read action for current state and first input
                action = table[state] && table[state][symbol];
            }

    _handle_error:
            // Handle parse error
            if (typeof action === 'undefined' || !action.length || !action[0]) {
                var error_rule_depth;
                var errStr = '';

                // Return the rule stack depth where the nearest error rule can be found.
                // Return FALSE when no error recovery rule was found.
                function locateNearestErrorRecoveryRule(state) {
                    var stack_probe = stack.length - 1;
                    var depth = 0;

                    // Try to recover from error
                    for(;;) {
                        // Check for error recovery rule in this state
                        if ((TERROR.toString()) in table[state]) {
                            return depth;
                        }
                        if (state === 0 || stack_probe < 2) {
                            return false; // No suitable error recovery rule available.
                        }
                        stack_probe -= 2; // popStack(1): [symbol, action]
                        state = stack[stack_probe];
                        ++depth;
                    }
                }

                if (!recovering) {
                    // First see if there's any chance at hitting an error recovery rule
                    error_rule_depth = locateNearestErrorRecoveryRule(state);

                    // Report error
                    expected = [];
                    for (p in table[state]) {
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                    }
                    
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + lexer.showPosition() + 
                                "\nExpecting " + expected.join(', ') + ", got '" + 
                                (this.terminals_[symbol] || symbol) + "'";
                    } else {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " +
                                (symbol == EOF ? "end of input" : ("'" + (this.terminals_[symbol] || symbol) + "'"));
                    }
                    
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected,
                        recoverable: (error_rule_depth !== false)
                    });
                } else if (preErrorSymbol !== EOF) {
                    error_rule_depth = locateNearestErrorRecoveryRule(state);
                }

                // Just recovered from another error
                if (recovering == 3) {
                    if (symbol === EOF || preErrorSymbol === EOF) {
                        throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                    }

                    // Discard current lookahead and grab another
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    symbol = lex();
                }

                // Try to recover from error
                if (error_rule_depth === false) {
                    throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
                }
                
                popStack(error_rule_depth);

                preErrorSymbol = (symbol == TERROR ? null : symbol); // Save the lookahead token
                symbol = TERROR;         // Insert generic error symbol as new lookahead
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3; // Allow 3 real symbols to be shifted before reporting a new error
            }

            // This shouldn't happen, unless resolve defaults are off
            if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }

            switch (action[0]) {
                case 1: // shift
                    stack.push(symbol);
                    vstack.push(lexer.yytext);
                    lstack.push(lexer.yylloc);
                    stack.push(action[1]); // Push state
                    symbol = null;
                    
                    if (!preErrorSymbol) { // Normal execution/no error
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        
                        if (recovering > 0) {
                            recovering--;
                        }
                    } else {
                        // Error just occurred, resume old lookahead from before error
                        symbol = preErrorSymbol;
                        preErrorSymbol = null;
                    }
                    break;

                case 2: // reduce
                    len = this.productions_[action[1]][1];

                    // Perform semantic action
                    yyval.$ = vstack[vstack.length - len]; // Default to $$ = $1
                    
                    // Default location, uses first token for firsts, last for lasts
                    yyval._$ = {
                        first_line: lstack[lstack.length - (len || 1)].first_line,
                        last_line: lstack[lstack.length - 1].last_line,
                        first_column: lstack[lstack.length - (len || 1)].first_column,
                        last_column: lstack[lstack.length - 1].last_column
                    };
                    
                    if (ranges) {
                        yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                    }
                    
                    r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                    if (typeof r !== 'undefined') {
                        return r;
                    }

                    // Pop off stack
                    if (len) {
                        stack = stack.slice(0, -1 * len * 2);
                        vstack = vstack.slice(0, -1 * len);
                        lstack = lstack.slice(0, -1 * len);
                    }

                    stack.push(this.productions_[action[1]][0]);    // Push nonterminal (reduce)
                    vstack.push(yyval.$);
                    lstack.push(yyval._$);
                    
                    // Goto new state = table[STATE][NONTERMINAL]
                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                    stack.push(newState);
                    break;

                case 3: // accept
                    return true;
            }
        }
    }
}

module.exports = CodeGenerator;