/**
 * lib/core/code-generator.js
 * 
 * Generates JavaScript code for parsers
 * 
 * Refactorings applied:
 * - Extract Class: Separated code generation from generator classes
 * - Decompose Conditional: Simplified generation logic
 */

"use strict";

const JSONSelect = require('JSONSelect');
const esprima = require('esprima');
const escodegen = require('escodegen');

/**
 * Generates JavaScript code for parsers
 */
class CodeGenerator {
    /**
     * Generate parser code
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated parser code
     */
    static generate(generator, options = {}) {
        // Combine options
        options = Object.assign({}, generator.options, options);
        
        // Check for illegal identifier
        if (!options.moduleName || !options.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {
            options.moduleName = "parser";
        }
        
        // Generate code based on module type
        switch (options.moduleType) {
            case "js":
                return this.generateModule(generator, options);
            case "amd":
                return this.generateAMDModule(generator, options);
            default:
                return this.generateCommonJSModule(generator, options);
        }
    }
    
    /**
     * Generate a standard JavaScript module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated module code
     */
    static generateModule(generator, options) {
        const moduleName = options.moduleName || "parser";
        let out = "/* parser generated by jison " + generator.version + " */\n";
        
        // Add module documentation
        out += this.generateDocumentation();
        
        // Add main module declaration
        out += (moduleName.match(/\./) ? moduleName : "var " + moduleName) +
                " = " + this.generateModuleExpr(generator);
        
        return out;
    }
    
    /**
     * Generate an AMD module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated AMD module code
     */
    static generateAMDModule(generator, options) {
        const module = this.generateModule_(generator);
        
        let out = '\n\ndefine(function(require){\n' +
            module.commonCode +
            '\nvar parser = ' + module.moduleCode +
            "\n" + generator.moduleInclude;
            
        // Add lexer if available
        if (generator.lexer && generator.lexer.generateModule) {
            out += '\n' + generator.lexer.generateModule() +
                  '\nparser.lexer = lexer;';
        }
        
        out += '\nreturn parser;' + '\n});';
        
        return out;
    }
    
    /**
     * Generate a CommonJS module
     * @param {Object} generator - Parser generator
     * @param {Object} options - Generation options
     * @returns {String} - Generated CommonJS module code
     */
    static generateCommonJSModule(generator, options) {
        const moduleName = options.moduleName || "parser";
        
        let out = this.generateModule(generator, options) +
            "\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {" +
            "\nexports.parser = " + moduleName + ";" +
            "\nexports.Parser = " + moduleName + ".Parser;" +
            "\nexports.parse = function () { return " + moduleName + ".parse.apply(" + moduleName + ", arguments); };" +
            "\nexports.main = " + String(options.moduleMain || this.commonjsMain) + ";" +
            "\nif (typeof module !== 'undefined' && require.main === module) {\n" +
            "  exports.main(process.argv.slice(1));\n}" +
            "\n}";
            
        return out;
    }
    
    /**
     * Generate a module expression
     * @param {Object} generator - Parser generator
     * @returns {String} - Generated module expression
     */
    static generateModuleExpr(generator) {
        const module = this.generateModule_(generator);
        
        let out = "(function(){\n";
        out += module.commonCode;
        out += "\nvar parser = " + module.moduleCode;
        out += "\n" + generator.moduleInclude;
        
        // Add lexer if available
        if (generator.lexer && generator.lexer.generateModule) {
            out += generator.lexer.generateModule();
            out += "\nparser.lexer = lexer;";
        }
        
        out += "\nfunction Parser () {\n  this.yy = {};\n}\n" +
            "Parser.prototype = parser;" +
            "parser.Parser = Parser;" +
            "\nreturn new Parser;\n})();";
            
        return out;
    }
    
    /**
     * Generate module documentation
     * @returns {String} - Documentation
     */
    static generateDocumentation() {
        return "/*\n" +
            "  Returns a Parser object of the following structure:\n" +
            "\n" +
            "  Parser: {\n" +
            "    yy: {}\n" +
            "  }\n" +
            "\n" +
            "  Parser.prototype: {\n" +
            "    yy: {},\n" +
            "    trace: function(),\n" +
            "    symbols_: {associative list: name ==> number},\n" +
            "    terminals_: {associative list: number ==> name},\n" +
            "    productions_: [...],\n" +
            "    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n" +
            "    table: [...],\n" +
            "    defaultActions: {...},\n" +
            "    parseError: function(str, hash),\n" +
            "    parse: function(input),\n" +
            "\n" +
            "    lexer: {\n" +
            "        EOF: 1,\n" +
            "        parseError: function(str, hash),\n" +
            "        setInput: function(input),\n" +
            "        input: function(),\n" +
            "        unput: function(str),\n" +
            "        more: function(),\n" +
            "        less: function(n),\n" +
            "        pastInput: function(),\n" +
            "        upcomingInput: function(),\n" +
            "        showPosition: function(),\n" +
            "        test_match: function(regex_match_array, rule_index),\n" +
            "        next: function(),\n" +
            "        lex: function(),\n" +
            "        begin: function(condition),\n" +
            "        popState: function(),\n" +
            "        _currentRules: function(),\n" +
            "        topState: function(),\n" +
            "        pushState: function(condition),\n" +
            "\n" +
            "        options: {\n" +
            "            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n" +
            "            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n" +
            "            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n" +
            "        },\n" +
            "\n" +
            "        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n" +
            "        rules: [...],\n" +
            "        conditions: {associative list: name ==> set},\n" +
            "    }\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  token location info (@$, _$, etc.): {\n" +
            "    first_line: n,\n" +
            "    last_line: n,\n" +
            "    first_column: n,\n" +
            "    last_column: n,\n" +
            "    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n" +
            "    text:        (matched text)\n" +
            "    token:       (the produced terminal token, if any)\n" +
            "    line:        (yylineno)\n" +
            "  }\n" +
            "  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n" +
            "    loc:         (yylloc)\n" +
            "    expected:    (string describing the set of expected tokens)\n" +
            "    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n" +
            "  }\n" +
            "*/\n";
    }
    
    /**
     * Generates the code of the parser module
     * @param {Object} generator - Parser generator
     * @returns {Object} - Module code parts
     * @private
     */
    static generateModule_(generator) {
        // Process the parse function
        let parseFn = String(this.parse);
        
        // Remove error recovery code if needed
        if (!generator.hasErrorRecovery) {
            parseFn = this.removeErrorRecovery(parseFn);
        }
        
        // Add token stack if requested
        if (generator.options['token-stack']) {
            parseFn = this.addTokenStack(parseFn);
        }
        
        // Generate table code
        const tableCode = this.generateTableCode(generator.table);
        
        // Generate module code
        const moduleCode = "{" + [
            "trace: " + String(generator.trace || this.trace),
            "yy: {}",
            "symbols_: " + JSON.stringify(generator.symbols_),
            "terminals_: " + JSON.stringify(generator.terminals_).replace(/"([0-9]+)":/g, "$1:"),
            "productions_: " + JSON.stringify(generator.productions_),
            "performAction: " + String(generator.performAction),
            "table: " + tableCode.moduleCode,
            "defaultActions: " + JSON.stringify(generator.defaultActions).replace(/"([0-9]+)":/g, "$1:"),
            "parseError: " + String(generator.parseError || (generator.hasErrorRecovery ? this.traceParseError : this.parseError)),
            "parse: " + parseFn
        ].join(",\n") + "};";
        
        return {
            commonCode: tableCode.commonCode,
            moduleCode: moduleCode
        };
    }
    
    /**
     * Generate code for the parser table
     * @param {Object} table - Parser table
     * @returns {Object} - Table code parts
     * @private
     */
    static generateTableCode(table) {
        let moduleCode = JSON.stringify(table);
        const variables = [this.createObjectCode];
        
        // Don't surround numerical property names with quotes
        moduleCode = moduleCode.replace(/"([0-9]+)"(?=:)/g, "$1");
        
        // Replace objects with several identical values by function calls
        moduleCode = moduleCode.replace(/\{\d+:[^\}]+,\d+:[^\}]+\}/g, object => {
            // Find the value that occurs with the highest number of keys
            let value, frequentValue, key, keys = {}, keyCount, maxKeyCount = 0;
            let keyValue, keyValues = [], keyValueMatcher = /(\d+):([^:]+)(?=,\d+:|\})/g;
            
            while ((keyValue = keyValueMatcher.exec(object))) {
                // For each value, store the keys where that value occurs
                key = keyValue[1];
                value = keyValue[2];
                keyCount = 1;
                
                if (!(value in keys)) {
                    keys[value] = [key];
                } else {
                    keyCount = keys[value].push(key);
                }
                
                // Remember this value if it is the most frequent one
                if (keyCount > maxKeyCount) {
                    maxKeyCount = keyCount;
                    frequentValue = value;
                }
            }
            
            // Construct the object with a function call if the most frequent value occurs multiple times
            if (maxKeyCount > 1) {
                // Collect all non-frequent values into a remainder object
                for (value in keys) {
                    if (value !== frequentValue) {
                        for (let k = keys[value], i = 0, l = k.length; i < l; i++) {
                            keyValues.push(k[i] + ':' + value);
                        }
                    }
                }
                
                keyValues = keyValues.length ? ',{' + keyValues.join(',') + '}' : '';
                
                // Create the function call `o(keys, value, remainder)`
                object = 'o([' + keys[frequentValue].join(',') + '],' + frequentValue + keyValues + ')';
            }
            
            return object;
        });
        
        // Replace frequently occurring number lists with variables
        let list;
        const lists = {};
        const listMatcher = /\[[0-9,]+\]/g;
        
        while (list = listMatcher.exec(moduleCode)) {
            lists[list] = (lists[list] || 0) + 1;
        }
        
        moduleCode = moduleCode.replace(listMatcher, list => {
            let listId = lists[list];
            
            if (typeof listId === 'number') {
                if (listId === 1) {
                    lists[list] = listId = list;
                } else {
                    lists[list] = listId = this.createVariable();
                    variables.push(listId + '=' + list);
                }
            }
            
            return listId;
        });
        
        return {
            commonCode: 'var ' + variables.join(',') + ';',
            moduleCode: moduleCode
        };
    }
    
    /**
     * Add token stack functionality to the parse function
     * @param {String} fn - Parse function code
     * @returns {String} - Modified parse function code
     * @private
     */
    static addTokenStack(fn) {
        try {
            const ast = esprima.parse(fn);
            const stackAst = esprima.parse(String(this.tokenStackLex)).body[0];
            stackAst.id.name = 'lex';
            
            const labeled = JSONSelect.match(':has(:root > .label > .name:val("_token_stack"))', ast);
            labeled[0].body = stackAst;
            
            return escodegen.generate(ast).replace(/_token_stack:\s?/, "").replace(/\\\\n/g, "\\n");
        } catch (e) {
            return fn;
        }
    }
    
