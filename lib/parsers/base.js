/*
 * File: lib/parsers/base.js
 * Source: Extracted from jison.js
 * Refactorings applied: 
 *   - Extract Method: Separated table generation 
 *   - Replace Constructor with Factory Method: Better parser initialization
 * Functionality: Base parser generation code
 */

var parser = require('../core/Parser').parser;
var typal = require('../utils/Typal').typal;

// default main method for generated commonjs modules
function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: ' + args[0] + ' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
}

var parserMethods = {
    trace: parser.trace,
    warn: parser.warn,
    error: parser.error,
    
    // Generate code for the given parser based on the input settings
    generate: function parser_generate(opt) {
        opt = typal.mix.call({}, this.options, opt);
        var code = "";

        // check for illegal identifier
        if (!opt.moduleName || !opt.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {
            opt.moduleName = "parser";
        }
        
        switch (opt.moduleType) {
            case "js":
                code = this.generateModule(opt);
                break;
            case "amd":
                code = this.generateAMDModule(opt);
                break;
            default:
                code = this.generateCommonJSModule(opt);
                break;
        }

        return code;
    },
    
    generateAMDModule: function generateAMDModule(opt) {
        opt = typal.mix.call({}, this.options, opt);
        var module = this.generateModule_();
        var out = '\n\ndefine(function(require){\n' + 
            module.commonCode + 
            '\nvar parser = ' + module.moduleCode + 
            "\n" + this.moduleInclude + 
            (this.lexer && this.lexer.generateModule ?
            '\n' + this.lexer.generateModule() +
            '\nparser.lexer = lexer;' : '') +
            '\nreturn parser;' +
            '\n});';
        return out;
    },
    
    generateCommonJSModule: function generateCommonJSModule(opt) {
        opt = typal.mix.call({}, this.options, opt);
        var moduleName = opt.moduleName || "parser";
        var out = this.generateModule(opt) +
            "\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {" +
            "\nexports.parser = " + moduleName + ";" +
            "\nexports.Parser = " + moduleName + ".Parser;" +
            "\nexports.parse = function() { return " + moduleName + ".parse.apply(" + moduleName + ", arguments); };" +
            "\nexports.main = " + String(opt.moduleMain || commonjsMain) + ";" +
            "\nif (typeof module !== 'undefined' && require.main === module) {\n" +
            "  exports.main(process.argv.slice(1));\n}" +
            "\n}";

        return out;
    },
    
    generateModule: function generateModule(opt) {
        opt = typal.mix.call({}, this.options, opt);
        var moduleName = opt.moduleName || "parser";
        var out = "/* parser generated by jison " + require('../../package.json').version + " */\n" +
            "/*\n" +
            "  Returns a Parser object of the following structure:\n" +
            "\n" +
            "  Parser: {\n" +
            "    yy: {}\n" +
            "  }\n" +
            "\n" +
            "  Parser.prototype: {\n" +
            "    yy: {},\n" +
            "    trace: function(),\n" +
            "    symbols_: {associative list: name ==> number},\n" +
            "    terminals_: {associative list: number ==> name},\n" +
            "    productions_: [...],\n" +
            "    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n" +
            "    table: [...],\n" +
            "    defaultActions: {...},\n" +
            "    parseError: function(str, hash),\n" +
            "    parse: function(input),\n" +
            "\n" +
            "    lexer: {\n" +
            "        EOF: 1,\n" +
            "        parseError: function(str, hash),\n" +
            "        setInput: function(input),\n" +
            "        input: function(),\n" +
            "        unput: function(str),\n" +
            "        more: function(),\n" +
            "        less: function(n),\n" +
            "        pastInput: function(),\n" +
            "        upcomingInput: function(),\n" +
            "        showPosition: function(),\n" +
            "        test_match: function(regex_match_array, rule_index),\n" +
            "        next: function(),\n" +
            "        lex: function(),\n" +
            "        begin: function(condition),\n" +
            "        popState: function(),\n" +
            "        _currentRules: function(),\n" +
            "        topState: function(),\n" +
            "        pushState: function(condition),\n" +
            "\n" +
            "        options: {\n" +
            "            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n" +
            "            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n" +
            "            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n" +
            "        },\n" +
            "\n" +
            "        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n" +
            "        rules: [...],\n" +
            "        conditions: {associative list: name ==> set},\n" +
            "    }\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  token location info (@$, _$, etc.): {\n" +
            "    first_line: n,\n" +
            "    last_line: n,\n" +
            "    first_column: n,\n" +
            "    last_column: n,\n" +
            "    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n" +
            "  }\n" +
            "\n" +
            "\n" +
            "  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n" +
            "    text:        (matched text)\n" +
            "    token:       (the produced terminal token, if any)\n" +
            "    line:        (yylineno)\n" +
            "  }\n" +
            "  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n" +
            "    loc:         (yylloc)\n" +
            "    expected:    (string describing the set of expected tokens)\n" +
            "    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n" +
            "  }\n" +
            "*/\n";
        out += (moduleName.match(/\./) ? moduleName : "var " + moduleName) +
                " = " + this.generateModuleExpr();

        return out;
    },
    
    generateModuleExpr: function generateModuleExpr() {
        var out = '';
        var module = this.generateModule_();

        out += "(function(){\n";
        out += module.commonCode;
        out += "\nvar parser = " + module.moduleCode;
        out += "\n" + this.moduleInclude;
        if (this.lexer && this.lexer.generateModule) {
            out += this.lexer.generateModule();
            out += "\nparser.lexer = lexer;";
        }
        out += "\nfunction Parser() {\n  this.yy = {};\n}\n" +
            "Parser.prototype = parser;" +
            "parser.Parser = Parser;" +
            "\nreturn new Parser;\n})();";

        return out;
    },
    
    // Generates the code of the parser module, which consists of two parts:
    // - module.commonCode: initialization code that should be placed before the module
    // - module.moduleCode: code that creates the module object
    generateModule_: function generateModule_() {
        var parseFn = String(parser.parse);
        if (!this.hasErrorRecovery) {
            parseFn = removeErrorRecovery(parseFn);
        }

        if (this.options['token-stack']) {
            parseFn = addTokenStack(parseFn);
        }

        // Generate code with fresh variable names
        var nextVariableId = 0;
        var tableCode = this.generateTableCode(this.table);

        // Generate the initialization code
        var commonCode = tableCode.commonCode;

        // Generate the module creation code
        var moduleCode = "{";
        moduleCode += [
            "trace: " + String(this.trace || parser.trace),
            "yy: {}",
            "symbols_: " + JSON.stringify(this.symbols_),
            "terminals_: " + JSON.stringify(this.terminals_).replace(/"([0-9]+)":/g, "$1:"),
            "productions_: " + JSON.stringify(this.productions_),
            "performAction: " + String(this.performAction),
            "table: " + tableCode.moduleCode,
            "defaultActions: " + JSON.stringify(this.defaultActions).replace(/"([0-9]+)":/g, "$1:"),
            "parseError: " + String(this.parseError || (this.hasErrorRecovery ? traceParseError : parser.parseError)),
            "parse: " + parseFn
        ].join(",\n");
        moduleCode += "};";

        return { commonCode: commonCode, moduleCode: moduleCode };
    },
    
    // Generate code that represents the specified parser table
    generateTableCode: function(table) {
        var moduleCode = JSON.stringify(table);
        var variables = ["o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o}"];
        var variableTokens = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
        var variableTokensLength = variableTokens.length;
        
        // Initialize nextVariableId at the function scope
        var nextVariableId = 0;

        // Creates a variable with a unique name
        function createVariable() {
            var id = nextVariableId++;
            var name = '$V';

            do {
                name += variableTokens[id % variableTokensLength];
                id = ~~(id / variableTokensLength);
            } while (id !== 0);

            return name;
        }

        // Rest of the function remains the same...
        // Don't surround numerical property name numbers in quotes
        moduleCode = moduleCode.replace(/"([0-9]+)"(?=:)/g, "$1");

        // Replace objects with several identical values by function calls
        moduleCode = moduleCode.replace(/\{\d+:[^\}]+,\d+:[^\}]+\}/g, function(object) {
            // Find the value that occurs with the highest number of keys
            var value, frequentValue, key, keys = {}, keyCount, maxKeyCount = 0,
                keyValue, keyValues = [], keyValueMatcher = /(\d+):([^:]+)(?=,\d+:|\})/g;

            while ((keyValue = keyValueMatcher.exec(object))) {
                // For each value, store the keys where that value occurs
                key = keyValue[1];
                value = keyValue[2];
                keyCount = 1;

                if (!(value in keys)) {
                    keys[value] = [key];
                } else {
                    keyCount = keys[value].push(key);
                }
                // Remember this value if it is the most frequent one
                if (keyCount > maxKeyCount) {
                    maxKeyCount = keyCount;
                    frequentValue = value;
                }
            }
            // Construct the object with a function call if the most frequent value occurs multiple times
            if (maxKeyCount > 1) {
                // Collect all non-frequent values into a remainder object
                for (value in keys) {
                    if (value !== frequentValue) {
                        for (var k = keys[value], i = 0, l = k.length; i < l; i++) {
                            keyValues.push(k[i] + ':' + value);
                        }
                    }
                }
                keyValues = keyValues.length ? ',' + keyValues.join(',') + '}' : '';
                // Create the function call `o(keys, value, remainder)`
                object = 'o([' + keys[frequentValue].join(',') + '],' + frequentValue + keyValues;
            }
            return object;
        });

        // Count occurrences of number lists
        var list;
        var lists = {};
        var listMatcher = /\[[0-9,]+\]/g;

        while (list = listMatcher.exec(moduleCode)) {
            lists[list] = (lists[list] || 0) + 1;
        }

        // Replace frequently occurring number lists with variables
        moduleCode = moduleCode.replace(listMatcher, function(list) {
            var listId = lists[list];
            // If listId is a number, it represents the list's occurrence frequency
            if (typeof listId === 'number') {
                // If the list does not occur frequently, represent it by the list
                if (listId === 1) {
                    lists[list] = listId = list;
                // If the list occurs frequently, represent it by a newly assigned variable
                } else {
                    lists[list] = listId = createVariable();
                    variables.push(listId + '=' + list);
                }
            }
            return listId;
        });

        // Return the variable initialization code and the table code
        return {
            commonCode: 'var ' + variables.join(',') + ';',
            moduleCode: moduleCode
        };
    },
    
    createParser: function createParser() {
        var p = eval(this.generateModuleExpr());

        // for debugging
        p.productions = this.productions;

        var self = this;
        function bind(method) {
            return function() {
                self.lexer = p.lexer;
                return self[method].apply(self, arguments);
            };
        }

        // backwards compatibility
        p.lexer = this.lexer;
        p.generate = bind('generate');
        p.generateAMDModule = bind('generateAMDModule');
        p.generateModule = bind('generateModule');
        p.generateCommonJSModule = bind('generateCommonJSModule');

        return p;
    }
};

// lex function that supports token stacks
function addTokenStack(fn) {
    var tokenStackCode = 'var token;\n' +
    'token = tstack.pop() || lexer.lex() || EOF;\n' +
    '// if token isn\'t its numeric value, convert\n' +
    'if (typeof token !== \'number\') {\n' +
    '   if (token instanceof Array) {\n' +
    '       tstack = token;\n' +
    '       token = tstack.pop();\n' +
    '   }\n' +
    '   token = self.symbols_[token] || token;\n' +
    '}\n' +
    'return token;';

    try {
        var esprima = require('esprima');
        var escodegen = require('escodegen');
        var JSONSelect = require('JSONSelect');
        
        var ast = esprima.parse(fn);
        var stackAst = esprima.parse(tokenStackCode).body[0];
        stackAst.id.name = 'lex';

        var labeled = JSONSelect.match(':has(:root > .label > .name:val("_token_stack"))', ast);
        labeled[0].body = stackAst;

        return escodegen.generate(ast).replace(/_token_stack:\s?/,"").replace(/\\\\n/g,"\\n");
    } catch (e) {
        return fn;
    }
}

// returns parse function without error recovery code
function removeErrorRecovery(fn) {
    try {
        var esprima = require('esprima');
        var escodegen = require('escodegen');
        var JSONSelect = require('JSONSelect');
        
        var ast = esprima.parse(fn);
        var labeled = JSONSelect.match(':has(:root > .label > .name:val("_handle_error"))', ast);
        var reduced_code = labeled[0].body.consequent.body[3].consequent.body;
        reduced_code[0] = labeled[0].body.consequent.body[1];     // remove the line: error_rule_depth = locateNearestErrorRecoveryRule(state);
        reduced_code[4].expression.arguments[1].properties.pop(); // remove the line: 'recoverable: error_rule_depth !== false'
        labeled[0].body.consequent.body = reduced_code;

        return escodegen.generate(ast).replace(/_handle_error:\s?/,"").replace(/\\\\n/g,"\\n");
    } catch (e) {
        return fn;
    }
}

// Error tracing function
function traceParseError(err, hash) {
    this.trace(err);
}

exports.parserMethods = parserMethods;